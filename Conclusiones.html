<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<title>Conclusiones</title>
</head>

<body>
<div id="contenido" align="left">
  <p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;La pr&aacute;ctica nos ha resultado interesante y nos ha ense&ntilde;ado bastantes cosas sobre el recorrido de espacios de estados y metodolog&iacute;as de resoluci&oacute;n de problemas bas&aacute;ndonos en la Inteligencia Artificial.&nbsp;<br />
  </p>
  <p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;A pesar de partir con una idea de como quer&iacute;amos hacer la implementaci&oacute;n, nos hemos encontrado diversas dificultades a lo largo del desarrollo. Una de las mayores ha sido la interfaz grafica. En nuestro trabajo con java en diversas asignaturas y laboratorios nunca nos hab&iacute;amos enfrentado a realizar una aplicaci&oacute;n tan visual y el manejo de Swing nos ha resultado especialmente dif&iacute;cil. Como IDE se ha utilizado principalmente NetBeans, ya que frente a Eclipse nos proporcionaba mejor infraestructura a la hora de realizar la interfaz.</p>
  <p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;Tambi&eacute;n&nbsp; destacamos que trabajar con librer&iacute;as externas no siempre es c&oacute;modo y f&aacute;cil. AIMA no estaba suficientemente documentada. Nos llevo un periodo de tiempo adaptarnos y entenderlas pero preferimos utilizarla antes que implementar nosotros todos los algoritmos ya que se supone est&aacute;n suficientemente testadas como para garantizar su funcionamiento, cosa que si implement&aacute;ramos todo nosotros desde el principio deber&iacute;amos asegurarnos y perder un valioso tiempo en ello.&nbsp;<br />
  </p>
  <p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;Hemos entendido la pr&aacute;ctica como un estudio de diversos algoritmos de b&uacute;squeda sobre un mismo entorno de ejecuci&oacute;n, es decir, las condiciones de ejecuci&oacute;n para un algoritmo y otro ten&iacute;an que ser las mismas. Este hecho nos ha llevado a mantener fijos los tipos de b&uacute;squeda de cada juego que hemos implementado para, de este modo, no ofrecer resultados enga&ntilde;osos al ejecutar la b&uacute;squeda global.&nbsp;&nbsp;<br />
  </p>
  <p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;Para simbolizar los enlaces entre las salas hemos utilizado juegos y no todos ellos con soluci&oacute;n ni utilizando el mismo algoritmo de b&uacute;squeda, precisamente para abarcar un mayor numero de b&uacute;squedas distintas y aprender a utilizar los distintos algoritmos. Adem&aacute;s, as&iacute; retrat&aacute;bamos m&aacute;s fielmente el funcionamiento de un casino, puesto que no siempre se gana.&nbsp;<br />
  </p>
  <p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;Debido a la importancia que juegan las pruebas en toda aplicaci&oacute;n, decidimos originar un generador de laberintos para as&iacute; poder realizar cuantas pruebas fueran necesarias bajo ciertas condiciones definibles en los archivos de configuraci&oacute;n.&nbsp;<br />
  </p>
  <p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;Por todo lo mencionado anteriormente nos ha resultado especialmente enriquecedora esta pr&aacute;ctica ampliando nuestro campo de conocimiento en multitud de &aacute;reas, mejorando nuestras habilidades como programadores y aumentando nuestra capacidad para depurar problemas complejos como puedan ser todos los tipos de b&uacute;squedas utilizados.</p>
  <p>&nbsp;</p>
</div>
</body>


</html>
